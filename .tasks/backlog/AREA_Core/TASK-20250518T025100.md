+++
id = "TASK-20250518T025100"
title = "Command Discovery and Contextual Execution System"
type = "specification"
status = "ðŸŸ¡ To Do"
priority = "ðŸ”¼ High"
created_date = "2025-05-18"
updated_date = "2025-05-18"
assigned_to = ""
phase = "backlog"
tags = [ "prd", "command-discovery", "feature-spec" ]
subdirectory = "AREA_Core"
+++

# Feature Specification: Command Discovery and Contextual Execution System

## Overview
Implement a lightweight command discovery system in core that allows clients (CLI, MCP, UI) to list available Claude commands and execute them with automatically injected context, eliminating manual ID copying and providing a foundation for future command orchestration.

## Requirements

### Functional Requirements
1. Provide command discovery API that reads from a centralized metadata JSON file
2. The metadata file contains information for all commands (similar to phases.json pattern)
3. Support simple `$ARGUMENTS` string replacement in command templates
4. Enable listing of all available commands with filtering by category
5. Allow retrieval of command content with `$ARGUMENTS` replaced
6. Support both direct execution (CLI) and template return (MCP/UI)
7. Include command categorization (planning, implementation, testing, etc.)
8. Support autonomous/interactive mode specification in metadata

### Technical Requirements
- Load metadata file on each request (no caching)
- Use Zod schemas for metadata file validation and type generation
- Async/await patterns for file operations
- Clear error messages for invalid metadata or missing command files
- Consider cross-platform compatibility if implementation allows

## UI/UX Design

### User Flow
1. User triggers command discovery (e.g., "scopecraft commands" or UI button)
2. System displays categorized list of available commands
3. User selects command or filters by category
4. System shows command description and required arguments
5. User confirms execution with current context (task ID, etc.)
6. Command launches with `$ARGUMENTS` replaced

### Key Integration Points
- **CLI**: New `commands` subcommand with list/execute options
- **MCP**: New tool `command_list` and `command_get` for discovery  
- **UI**: Command palette or dropdown in task/feature detail views
- **Context Menu**: Right-click on tasks/features to see available commands

## Technical Design

### Components Affected
- `src/core/command-discovery.ts`: New module for discovery logic
- `src/core/types.ts`: Add Zod schemas and derived types
- `src/cli/commands.ts`: Add new command subcommands
- `src/mcp/handlers.ts`: Add command discovery handlers
- `tasks-ui/src/components/`: Add CommandSelector component

### Data Model (Conceptual)

*Note: These are illustrative examples. Actual implementation will use Zod schemas with derived types.*

```typescript
// Example of how the Zod schema might look conceptually
const CommandMetadataSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  category: z.enum(['planning', 'implementation', 'testing', 'documentation', 'utility']),
  mode: z.enum(['autonomous', 'interactive', 'both']),
  arguments: z.object({
    taskId: z.boolean().optional(),
    featureId: z.boolean().optional(),
    custom: z.array(z.string()).optional()
  }),
  path: z.string()
});

const CommandsFileSchema = z.object({
  version: z.string(),
  commands: z.array(CommandMetadataSchema)
});

// Types would be derived: type CommandMetadata = z.infer<typeof CommandMetadataSchema>
```

### API Design (Conceptual)
- `discoverCommands(): Promise<Command[]>` - Load and validate metadata
- `getCommand(id: string): Promise<Command>` - Get specific command with content
- `getCommandContent(id: string, args: string): string` - Get content with $ARGUMENTS replaced

## Implementation Notes

### Discovery Process
1. Load `.scopecraft/commands.json` metadata file
2. Validate against Zod schema
3. For each command in metadata, verify the `.md` file exists
4. Return command list

### Argument Replacement
- Simple string replacement: all instances of `$ARGUMENTS` are replaced
- No complex templating or variable substitution
- If no arguments provided, `$ARGUMENTS` is replaced with empty string

### Client-Specific Handling
- **CLI**: Based on mode, either spawn interactive session or return immediately
- **MCP**: Return filled template for agent execution (typically autonomous mode)
- **UI**: Inject into prompt field (autonomous mode only currently)

### Error Handling
- File not found errors for missing command files
- Schema validation errors for invalid metadata JSON
- Clear messages when required files are missing

## Testing Approach

### What to Test
- Metadata file loading and schema validation
- `$ARGUMENTS` replacement in command content
- Command filtering by category
- Error handling for missing files
- Basic unit test for core functionality
- CLI command execution (both modes)
- MCP tool integration
- UI component behavior

## Task Breakdown Preview

### Core (AREA_Core)
- Define Zod schemas for metadata
- Implement command discovery module  
- Add simple `$ARGUMENTS` replacement logic
- Create metadata loading and validation

### CLI (AREA_cli)
- Add `commands` subcommand
- Implement list and execute operations
- Support both autonomous and interactive modes
- Add argument passing logic

### MCP (AREA_MCP)
- Add command_list and command_get tools
- Pass task/feature IDs as arguments
- Return filled templates for execution

### UI (AREA_UI)
- Create CommandSelector component
- Add command palette to task/feature views
- Display commands by category
- Handle autonomous mode execution

### Documentation (AREA_Documentation)
- Document metadata file format
- Create example commands metadata
- Write user guide for command discovery
- Document mode differences

## Metadata Population

The initial population of the commands metadata file could be:
- Manually created based on existing commands
- Agent-driven scanning and cataloging
- Automated script to scan and generate

This is a separate concern from the discovery system itself.

## Human Review Required

### Technical decisions needing verification:
- [ ] Metadata file location: `.scopecraft/commands.json` appropriate?
- [ ] Zod schema structure: Does it capture all needed metadata?
- [ ] Mode naming: Is 'autonomous' vs 'interactive' clear?
- [ ] Category list: Are the categories comprehensive?

### Design decisions to confirm:
- [ ] Single metadata file vs per-command approach correct?
- [ ] Category-based organization sufficient?
- [ ] Mode support needed from start?

### Implementation concerns:
- [ ] Should metadata population be included in MVP?
- [ ] Is manual metadata creation acceptable initially?
- [ ] Any additional command metadata needed?
