+++
id = "TASK-20250516T134141"
title = "Prompt-Only Streaming Endpoint (WebSocket-First)"
type = "feature"
status = "üîµ In Progress"
priority = "‚ñ∂Ô∏è Medium"
created_date = "2025-05-16"
updated_date = "2025-05-16"
assigned_to = ""
phase = "release-v1"
subdirectory = "AREA_TaskWorktree"
tags = [ "websocket", "streaming", "api", "claude-integration" ]
+++

# Feature Document  
"Prompt-Only Streaming Endpoint (WebSocket-First)"

## 1 Purpose  
Add a lightweight WebSocket endpoint to the Bun server that:

1. Accepts a single JSON envelope `{ prompt, meta }` where  
   ‚Ä¢ `prompt` = free-form text supplied by the user  
   ‚Ä¢ `meta`   = task / feature identifier appended for traceability  
2. Runs `claude code -p "<prompt>\n\n[meta:<meta>]" --output-format stream-json`.  
3. Streams each JSON line from Claude back to the client **as-is** in real time.  
4. Allows the front-end to render assistant text, tool calls, and tool results
   exactly as they arrive.  

No tmux or task work-tree switching is involved; each request is a short-lived,
headless process.

---

## 2 API Specification  

| Property | Value |
|---|---|
| URL         | `ws://127.0.0.1:8080/ws/claude` |
| Sub-protocol | *(none)* |
| First client frame | `{"prompt":"‚Ä¶","meta":"TASK-123"}` |
| Server frames | Raw UTF-8 lines emitted by `claude` (`\n` delimited). |
| Error frame | `{"error":"‚Ä¶msg‚Ä¶"}` then socket closes with code 1011 |
| Normal close | Code 1000 when `claude` exits 0 |
| Timeout     | Server kills Claude and closes 1011 after 5 minutes |

Validation rules  
‚Ä¢ `prompt` length ‚â§ 8 192 bytes.  
‚Ä¢ `meta` must match regex `^[A-Z0-9_\-]+$`.

---

## 3 Incremental Work-Plan (hand off to AI coder)

| Step | Title | Success Criteria |
|---|---|---|
| 1 | `streamClaude(prompt: string)` helper | Unit test spawns CLI, exits 0, captures "Hello". |
| 2 | WebSocket endpoint skeleton | `wscat ‚Ä¶`, send `{}` ‚Üí server responds `{error:"Prompt required"}` and closes 1008. |
| 3 | Prompt + meta validation | Send good envelope, socket stays open; bad meta closes 1008. |
| 4 | Pipe `stdout` chunks to WS | Envelope `"Hello"` streams one line containing `"Hello"`. |
| 5 | Pipe `stderr` as error frames | Force CLI error (`claude --badflag`) ‚Üí client receives `{error:"‚Ä¶"}`, close 1011. |
| 6 | 5-minute timeout guard | Long-running prompt closes 1011 at T+300 s. |
| 7 | Front-end demo page | Button opens WS, live-renders chunks using parser below. |

Each step is independently verifiable yet the final result is the full WS solution‚Äîno intermediate REST endpoint required.

---

## 4 Server Implementation Sketch (Bun v1.1+)

```ts
// streamClaude.ts -------------------------------------------------------
export function streamClaude(fullPrompt: string) {
  return Bun.spawn({
    cmd: ["claude", "code", "-p", fullPrompt,
          "--output-format", "stream-json"],
    stdout: "pipe",
    stderr: "pipe",
  });
}

// server.ts -------------------------------------------------------------
import { serve } from "bun";
import { streamClaude } from "./streamClaude.ts";
const META_RE = /^[A-Z0-9_\-]+$/;

serve({
  port: 8080,
  websocket: {
    open(ws) { ws.send(JSON.stringify({info:"send {prompt,meta}"})); },

    async message(ws, data) {
      let env;
      try { env = JSON.parse(data as string); } catch { return bad(ws,"Bad JSON"); }
      if (!env.prompt || !META_RE.test(env.meta)) return bad(ws,"Invalid prompt/meta");

      const full = `${env.prompt}\n\n[meta:${env.meta}]`;
      const proc = streamClaude(full);
      const timeout = setTimeout(() => { proc.kill(); }, 300_000);

      proc.stdout!.on("data", c => ws.send(c));
      proc.stderr!.on("data", c => ws.send(JSON.stringify({error:c.toString()})));
      proc.exited.then(code => { clearTimeout(timeout); ws.close(code?1011:1000); });

      // Ignore further client messages
      ws.onmessage = () => {};
    }
  }
});

function bad(ws, msg) { ws.send(JSON.stringify({error:msg})); ws.close(1008); }
```

---

## 5 Client-Side Parsing & Rendering Guidelines  

### 5.1 JSON Chunk Shapes  

| `content[*].type` | Render as | Notes |
|---|---|---|
| `"text"`        | Markdown | Append to bubble `assistant` |
| `"tool_use"`    | üì° Tool Call | Show name + `<details>` for input JSON |
| `"tool_result"` | üõ†Ô∏è Tool Result | Attach to matching tool_use via `tool_use_id` |

### 5.2 Parsing Algorithm  

```ts
function handleChunk(line){
  const msg = JSON.parse(line);

  if (msg.type === "message"){
    ensureBubble(msg.id, msg.role);
    for (const block of msg.content){
      if(block.type==="text") appendMarkdown(msg.id, block.text);
      if(block.type==="tool_use") renderToolCall(msg.id, block);
    }
    if (msg.stop_reason==="end_turn") closeBubble(msg.id);
    return;
  }

  if (msg.role==="user"){
    msg.content?.filter(b=>b.type==="tool_result")
                .forEach(b=>renderToolResult(b.tool_use_id,b.content));
  }

  if (msg.error) showError(msg.error);
}
```

### 5.3 UI Conventions  

| Element | Style |
|---|---|
| Assistant bubble | dark background, animated cursor while streaming |
| Tool Call | grey card, icon üì°, expandable JSON input |
| Tool Result | matched under the call, icon üõ†Ô∏è, expandable output |
| Error | red banner inside the modal |

---

## 6 Testing Checklist  

1. "Hello" prompt streams "Hello".  
2. Prompt with tool call shows üì° block; subsequent tool_result is attached.  
3. Invalid meta closes socket 1008.  
4. Timeout fires after 5 min.  
5. Multiple browser tabs run prompts concurrently without cross-talk.

---

## 7 Future Extensions  

‚Ä¢ Allow optional `model`, `temperature` fields in the envelope.  
‚Ä¢ Persist complete conversation JSON to task notes.  
‚Ä¢ Support markdown ‚Üí HTML conversion on server for thinner client.
